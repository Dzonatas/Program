<?xml version="1.0" ?>
<auto>
<_xml_reader>
var s = System.IO.File.OpenText( "/tmp/&guid;.il.xml" ) ;
var t = s.ReadToEnd() ;
var e = t.GetEnumerator() ;
//string INSTANCE_entity ;
string n = string.Empty ;
string l = string.Empty ;
string p = string.Empty ;
bool process = false ;
while( e.MoveNext() )
	{
	&debug_nop;
	if( e.Current == '&lt;' )
		{
		if( process )
			_accept.Auto.Text(l) ;
		l = string.Empty ;
		e.MoveNext() ;
		if( e.Current == '_' )
			{
			process = true ;
			e.MoveNext() ;
			while( e.Current >= '0' &amp;&amp; '9' >= e.Current )
				{
				n += e.Current ;
				e.MoveNext() ;
				}
			_accept.Codex.Switch(int.Parse(n)).Element() ;
			}
		else
			process = false ;
		while( e.Current != '>' )
			e.MoveNext() ;
		n = string.Empty ;
		continue ;
		}
	if( e.Current == '&amp;' )
		{
		if( process )
			_accept.Auto.Text(l) ;
		l = string.Empty ;
		e.MoveNext() ;
		if( e.Current == '_' )
			{
			process = true ;
			e.MoveNext() ;
			/*
			while( e.Current >= '0' &amp;&amp; '9' >= e.Current )
				{
				n += e.Current ;
				e.MoveNext() ;
				}
			*/
			while( e.Current != '_' )
				e.MoveNext() ;
			e.MoveNext() ;
			while( e.Current >= '0' &amp;&amp; '9' >= e.Current )
				{
				n += e.Current ;
				e.MoveNext() ;
				}
			_accept.Codex.Switch(int.Parse(n)).EntityReference() ;
			}
		else
			process = false ;
		while( e.Current != ';' )
			e.MoveNext() ;
		n = string.Empty ;
		continue ;
		}
	if( process )
		{
		l += e.Current ;
		if( p != string.Empty )
			{
			for( int i = int.Parse(p) ; i > 1 ; --i )
				{
				e.MoveNext() ;
				l += e.Current ;
				}
			p = string.Empty ;
			}
		}
	}
s.Close() ;
</_xml_reader>
<A335-Xo_t-Build-iDNA-1>
interface Item { }
namespace _accept {
public partial class A335 {
static A335() {}
#if EMBED
public readonly static char[] MSB = new char[] { ' ', '.' } ;
public static void Main( string[] args )
	{
	new Automa._auto() ;
	}
#endif
}
struct iDNA {
&list;
}
public abstract class Auto {
	static public Tokenset.Token Token ;
	public abstract string LHS { get; }
	public abstract string[] RHS { get; }
}
public class _Auto : Auto {
	public override string LHS { get { return string.Empty ; } }
	public override string[] RHS { get { return null ; } }
}
public static class Codex
	{
	public static Auto Switch( Tokenset.Token t ) {
		switch( t.point ) {
</A335-Xo_t-Build-iDNA-1>
<A335-Xo_t-Build-iDNA-2>
		case &i; : return new &namespace;.&signal;(t) ;
</A335-Xo_t-Build-iDNA-2>
<A335-Xo_t-Build-iDNA-4>
		default: return new _Auto() ;
		}
	}
	}
}
</A335-Xo_t-Build-iDNA-4>
<A335-Xo_t-Build-iDNA-5i>
namespace basic { &lease;
interface &interface; {
&I;
}
}
</A335-Xo_t-Build-iDNA-5i>
<A335-Xo_t-Build-iDNA-5>
namespace &namespace; {
public struct iDNA {
	public static readonly char[]   Entity  = &Entity; ;
&list;
}
public partial class  &signal;
	: _accept.Auto, &interface;
	{
	static readonly char[]   lhs = &lhs; ;
	public override string   LHS { get { return new string(lhs) ; } }
	public override string[] RHS { get { return rhs ; } }
	static readonly string[] rhs = &rhs; ;
	public &signal;( Tokenset.Token t )
		{
		System.Console.WriteLine("&signal;"+t) ;
		_accept.Codex.Switch( Tokenset.Input ) ;
		}
	}
}
</A335-Xo_t-Build-iDNA-5>
<A335-Xo_t-list-top>
	public const           char     C       = '&glyph;' ;
	public static readonly int[]    LookAhead  = &lookahead; ;
</A335-Xo_t-list-top>
<A335-Xo_t-list>
	public static readonly char     &rule;_&point; = &global; ;
</A335-Xo_t-list>
<A335-Xo_t-_io-0>
namespace Automa {
interface State {
	int[,]               Shiftset                  { get; }
	int[,]               Gotoset                   { get; }
	string[]             Typeset                   { get; }
	int[]                Symbolset                 { get; }
	int[]                Stateset                  { get; }
	int[]                Ruleset                   { get; }
	int[]                Pointset                  { get; }
	int[,]               Reductionset              { get; }
	int                  Default                   { get; }
	}
public class _auto : State {
	public int[,]   Shiftset     { get { return shiftset ; } }
	public int[,]   Gotoset      { get { return gotoset ; } }
	public string[] Typeset      { get { return typeset ; } }
	public int[]    Symbolset    { get { return symbolset ; } }
	public int[]    Stateset     { get { return stateset ; } }
	public int[]    Ruleset      { get { return ruleset ; } }
	public int[]    Pointset     { get { return pointset ; } }
	public int[,]   Reductionset { get { return reductionset ; } }
	public int      Default      { get { return _default ; } }
	public static readonly int[,]   shiftset   ;
	public static readonly int[,]   gotoset   ;
	public static readonly string[] typeset   ;
	public static readonly int[]    symbolset ;
	public static readonly int[]    stateset  ;
	public static readonly int[]    ruleset   ;
	public static readonly int[]    pointset  ;
	public static readonly int[,]   reductionset ;
	public static readonly int      _default   ;
	public _auto() {
		new &namespace;.&signal;( Tokenset.Input ) ;
	}
}
</A335-Xo_t-_io-0>
<A335-Xo_t-_io-1>
public class &point; : _auto, State
	{
	public new static readonly int[,]   Shiftset  = &shiftset; ;
	public new static readonly int[,]   Gotoset   = &gotoset; ;
	public new static readonly string[] Typeset   = &typeset; ;
	public new static readonly int[]    Symbolset = &symbolset; ;
	public new static readonly int[]    Stateset  = &stateset; ;
	public new static readonly int[]    Ruleset   = &ruleset; ;
	public new static readonly int[]    Pointset  = &pointset; ;
	public new static readonly int[,]   Reductionset  = &reductionset; ;
	public new static readonly int      Default   = &rule; ;
	}
</A335-Xo_t-_io-1>
<A335-Xo_t-_io-2>
}
</A335-Xo_t-_io-2>
<main_c>
#include &lt;stdlib.h>
#include &lt;sys/types.h>
#include &lt;sys/wait.h>
#include &lt;stdio.h>
#include &lt;unistd.h>
int debug = 0 ;
fasm(char *const argv[])
{
pid_t pid ;
int status ;
if( (pid = vfork()) == 0 )
	{
	if( debug )
		printf("%s\n",argv[0]) ;
	execve( argv[0] , argv, 0 ) ;
	abort() ;
	}
waitpid( pid, &amp;status, 0 ) ;
}
main(int argc, char** argv, char** envp)
{
if(argc>1) debug = 1 ;
&list;
}
</main_c>
<fasm_c>
fasm( (char*[]) &A;&argv; ) ;
</fasm_c>
</auto>
